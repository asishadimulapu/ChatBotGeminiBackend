{"version":3,"sources":["authController.js"],"names":["bcrypt","require","jwt","exports","register","req","res","next","_req$body","name","email","password","hashedPassword","user","regeneratorRuntime","async","_context","prev","body","awrap","User","findOne","sent","abrupt","status","json","msg","hash","create","trim","toLowerCase","id","_id","t0","stop","login","_req$body2","token","_context2","compare","sign","expiresIn"],"mappings":"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","file":"authController.min.js","sourcesContent":["const bcrypt = require('bcryptjs');\r\nconst jwt = require('jsonwebtoken');\r\nconst User = require('../models/User');\r\n\r\nexports.register = async (req, res, next) => {\r\n  try {\r\n    const { name, email, password } = req.body;\r\n    \r\n    // Check if user already exists\r\n    const existingUser = await User.findOne({ email });\r\n    if (existingUser) {\r\n      return res.status(400).json({ msg: 'User already exists with this email' });\r\n    }\r\n\r\n    // Hash password with higher salt rounds for better security\r\n    const saltRounds = 12;\r\n    const hashedPassword = await bcrypt.hash(password, saltRounds);\r\n    \r\n    // Create user\r\n    const user = await User.create({ \r\n      name: name.trim(), \r\n      email: email.toLowerCase().trim(), \r\n      password: hashedPassword \r\n    });\r\n\r\n    res.status(201).json({ \r\n      msg: 'User registered successfully',\r\n      user: {\r\n        id: user._id,\r\n        name: user.name,\r\n        email: user.email\r\n      }\r\n    });\r\n  } catch (err) {\r\n    next(err); // Pass error to error handling middleware\r\n  }\r\n};\r\n\r\nexports.login = async (req, res, next) => {\r\n  try {\r\n    const { email, password } = req.body;\r\n    \r\n    // Find user and include password for comparison\r\n    const user = await User.findOne({ email: email.toLowerCase().trim() });\r\n    if (!user) {\r\n      return res.status(400).json({ msg: 'Invalid email or password' });\r\n    }\r\n\r\n    // Compare password\r\n    const isPasswordValid = await bcrypt.compare(password, user.password);\r\n    if (!isPasswordValid) {\r\n      return res.status(400).json({ msg: 'Invalid email or password' });\r\n    }\r\n\r\n    // Generate JWT token with expiration\r\n    const token = jwt.sign(\r\n      { userId: user._id }, \r\n      process.env.JWT_SECRET,\r\n      { expiresIn: '24h' } // Token expires in 24 hours\r\n    );\r\n\r\n    res.json({ \r\n      token, \r\n      user: { \r\n        id: user._id, \r\n        name: user.name,\r\n        email: user.email\r\n      }\r\n    });\r\n  } catch (err) {\r\n    next(err); // Pass error to error handling middleware\r\n  }\r\n};\r\n"]}